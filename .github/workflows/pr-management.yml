name: PR Management

on:
  pull_request:
    types: [opened, synchronize, reopened, edited]
  workflow_call:
    outputs:
      approved:
        description: 'Whether PR validation passed'
        value: ${{ jobs.validate.outputs.validation-passed }}

jobs:
  validate:
    name: PR Validation
    runs-on: ubuntu-latest
    outputs:
      validation-passed: ${{ steps.final.outputs.approved }}
    permissions:
      pull-requests: write
      contents: read
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Validate conventional commits
        uses: wagoid/commitlint-github-action@v6
        with:
          configFile: .commitlintrc.json
          failOnWarnings: false

      - name: Validate PR title format
        uses: amannn/action-semantic-pull-request@v5
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          types: |
            feat
            fix
            docs
            style
            refactor
            perf
            test
            build
            ci
            chore
          scopes: |
            gui
            core
            overlay
            config
            build
            ci
            deps
          requireScope: false
          subjectPattern: ^[a-z].+$
          wip: false

      - name: Check branch naming convention
        uses: deepakputhraya/action-branch-name@master
        with:
          regex: '^(feat|fix|docs|style|refactor|perf|test|build|ci|chore|hotfix)\/[a-z0-9-]+$|^(main|develop)$'
          allowed_prefixes: 'feat,fix,docs,style,refactor,perf,test,build,ci,chore,hotfix'
          ignore: main,develop
          min_length: 5

      - name: Check for merge conflicts
        uses: eps1lon/actions-label-merge-conflict@v3
        with:
          dirtyLabel: 'merge-conflict'
          repoToken: ${{ secrets.GITHUB_TOKEN }}

      - name: Final validation status
        id: final
        run: |
          echo "approved=true" >> $GITHUB_OUTPUT
          echo "‚úÖ PR validation completed"

  process:
    name: PR Processing & Statistics
    needs: validate
    runs-on: ubuntu-latest
    permissions:
      contents: read
      pull-requests: write
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Label by size
        uses: codelytv/pr-size-labeler@v1
        with:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          xs_label: 'size/xs'
          xs_max_size: 10
          s_label: 'size/s'
          s_max_size: 100
          m_label: 'size/m'
          m_max_size: 500
          l_label: 'size/l'
          l_max_size: 1000
          xl_label: 'size/xl'
          fail_if_xl: false

      - name: Label by files
        uses: actions/labeler@v5
        with:
          repo-token: ${{ secrets.GITHUB_TOKEN }}
          configuration-path: .github/labeler.yml

      - name: Label by conventional commit & validate PR
        uses: actions/github-script@v7
        with:
          script: |
            const pr = context.payload.pull_request;
            const title = pr.title.toLowerCase();

            const labels = [];

            // Conventional commit types
            if (title.startsWith('feat:') || title.startsWith('feat(')) {
              labels.push('type/feature');
            } else if (title.startsWith('fix:') || title.startsWith('fix(')) {
              labels.push('type/bug');
            } else if (title.startsWith('docs:') || title.startsWith('docs(')) {
              labels.push('type/documentation');
            } else if (title.startsWith('style:') || title.startsWith('style(')) {
              labels.push('type/style');
            } else if (title.startsWith('refactor:') || title.startsWith('refactor(')) {
              labels.push('type/refactor');
            } else if (title.startsWith('perf:') || title.startsWith('perf(')) {
              labels.push('type/performance');
            } else if (title.startsWith('test:') || title.startsWith('test(')) {
              labels.push('type/test');
            } else if (title.startsWith('chore:') || title.startsWith('chore(')) {
              labels.push('type/chore');
            } else if (title.startsWith('ci:') || title.startsWith('ci(')) {
              labels.push('type/ci');
            } else if (title.startsWith('build:') || title.startsWith('build(')) {
              labels.push('type/build');
            }

            // Breaking changes
            if (title.includes('!:') || pr.body?.includes('BREAKING CHANGE')) {
              labels.push('breaking-change');
            }

            // Check PR description
            if (!pr.body || pr.body.trim().length < 10) {
              labels.push('needs-description');
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: pr.number,
                body: '‚ö†Ô∏è This PR needs a description. Please add details about what changes were made and why.'
              });
            }

            if (labels.length > 0) {
              await github.rest.issues.addLabels({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: pr.number,
                labels: labels
              });
            }

      - name: Generate PR statistics
        uses: actions/github-script@v7
        with:
          script: |
            const pr = context.payload.pull_request;

            // Get PR diff stats
            const files = await github.rest.pulls.listFiles({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: pr.number
            });

            let additions = 0;
            let deletions = 0;
            let filesChanged = files.data.length;
            let filesAdded = 0;
            let filesDeleted = 0;
            let filesModified = 0;

            files.data.forEach(file => {
              additions += file.additions;
              deletions += file.deletions;

              if (file.status === 'added') filesAdded++;
              else if (file.status === 'removed') filesDeleted++;
              else if (file.status === 'modified') filesModified++;
            });

            // Get commit count
            const commits = await github.rest.pulls.listCommits({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: pr.number
            });

            const commitCount = commits.data.length;

            // Get changed file types
            const fileTypes = {};
            files.data.forEach(file => {
              const ext = file.filename.split('.').pop();
              fileTypes[ext] = (fileTypes[ext] || 0) + 1;
            });

            const fileTypesList = Object.entries(fileTypes)
              .sort((a, b) => b[1] - a[1])
              .slice(0, 5)
              .map(([ext, count]) => `\`${ext}\` **${count}**`)
              .join(' ‚Ä¢ ');

            // Calculate PR size (matching size/* labels)
            const prSize = additions + deletions;
            let sizeEmoji, sizeLabel;
            if (prSize < 10) {
              sizeEmoji = 'üü¢';
              sizeLabel = 'XS';
            } else if (prSize < 100) {
              sizeEmoji = 'üü¢';
              sizeLabel = 'S';
            } else if (prSize < 500) {
              sizeEmoji = 'üü°';
              sizeLabel = 'M';
            } else if (prSize < 1000) {
              sizeEmoji = 'üü†';
              sizeLabel = 'L';
            } else {
              sizeEmoji = 'üî¥';
              sizeLabel = 'XL';
            }

            // Check if comment already exists
            const comments = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: pr.number
            });

            const botComment = comments.data.find(comment =>
              comment.user.type === 'Bot' &&
              comment.body.includes('üìä Pull Request Statistics')
            );

            const commentBody = [
              '## üìä Pull Request Statistics',
              '',
              '### üìà Changes Overview',
              '',
              '| Metric | Value |',
              '|--------|-------|',
              `| üü¢ **Lines Added** | \`+${additions}\` |`,
              `| üî¥ **Lines Deleted** | \`-${deletions}\` |`,
              `| üìä **Net Change** | \`${additions - deletions > 0 ? '+' : ''}${additions - deletions}\` |`,
              `| üìÅ **Files Changed** | \`${filesChanged}\` |`,
              `| ‚ú® **Files Added** | \`${filesAdded}\` |`,
              `| ‚úèÔ∏è **Files Modified** | \`${filesModified}\` |`,
              `| üóëÔ∏è **Files Deleted** | \`${filesDeleted}\` |`,
              `| üìù **Commits** | \`${commitCount}\` |`,
              '',
              '### üì¶ PR Size',
              '',
              `${sizeEmoji} **${sizeLabel}** ‚Äî \`${prSize}\` total changes`,
              '',
              '### üìÑ Top File Types',
              '',
              fileTypesList || '*No files changed*',
              '',
              '---',
              '',
              '<sub>üí° *This comment updates automatically on each push*</sub>'
            ].join('\n');

            if (botComment) {
              // Update existing comment
              await github.rest.issues.updateComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: botComment.id,
                body: commentBody
              });
            } else {
              // Create new comment
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: pr.number,
                body: commentBody
              });
            }
