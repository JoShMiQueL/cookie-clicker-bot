name: 'PR Statistics & Labeling'

on:
  pull_request_target:
    types: [opened, reopened, synchronize]
  pull_request:
    types: [opened, reopened, synchronize]

jobs:
  pr-triage:
    name: PR Triage and Statistics
    runs-on: ubuntu-latest
    permissions:
      contents: read
      pull-requests: write
      issues: write

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Label by size
        uses: codelytv/pr-size-labeler@v1
        with:
          GITHUB_TOKEN: ${{ github.token }}
          xs_label: 'size/xs'
          xs_max_size: 10
          s_label: 'size/s'
          s_max_size: 100
          m_label: 'size/m'
          m_max_size: 500
          l_label: 'size/l'
          l_max_size: 1000
          xl_label: 'size/xl'
          fail_if_xl: false

      - name: Label by files
        uses: actions/labeler@v5
        with:
          repo-token: ${{ github.token }}
          configuration-path: .github/labeler.yml

      - name: Label by conventional commit
        uses: actions/github-script@v7
        id: labeler
        with:
          script: |
            const pr = context.payload.pull_request;
            const title = pr.title.toLowerCase();

            const labels = [];

            // Conventional commit types
            if (title.startsWith('feat:') || title.startsWith('feat(')) {
              labels.push('type/feature');
            } else if (title.startsWith('fix:') || title.startsWith('fix(')) {
              labels.push('type/bug');
            } else if (title.startsWith('docs:') || title.startsWith('docs(')) {
              labels.push('type/documentation');
            } else if (title.startsWith('style:') || title.startsWith('style(')) {
              labels.push('type/style');
            } else if (title.startsWith('refactor:') || title.startsWith('refactor(')) {
              labels.push('type/refactor');
            } else if (title.startsWith('perf:') || title.startsWith('perf(')) {
              labels.push('type/performance');
            } else if (title.startsWith('test:') || title.startsWith('test(')) {
              labels.push('type/test');
            } else if (title.startsWith('chore:') || title.startsWith('chore(')) {
              labels.push('type/chore');
            } else if (title.startsWith('ci:') || title.startsWith('ci(')) {
              labels.push('type/ci');
            } else if (title.startsWith('build:') || title.startsWith('build(')) {
              labels.push('type/build');
            }

            // Breaking changes
            if (title.includes('!:') || pr.body?.includes('BREAKING CHANGE')) {
              labels.push('breaking-change');
            }

            // Check PR description
            if (!pr.body || pr.body.trim().length < 10) {
              labels.push('needs-description');
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: pr.number,
                body: '‚ö†Ô∏è This PR needs a description. Please add details about what changes were made and why.'
              });
            }

            if (labels.length > 0) {
              await github.rest.issues.addLabels({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: pr.number,
                labels: labels
              });
            }

      - name: Generate PR statistics
        uses: actions/github-script@v7
        with:
          script: |
            const pr = context.payload.pull_request;

            // Get all files in the PR with pagination
            let files = [];
            let page = 1;
            let response;
            
            do {
              response = await github.rest.pulls.listFiles({
                owner: context.repo.owner,
                repo: context.repo.repo,
                pull_number: pr.number,
                per_page: 100,
                page: page++
              });
              files = files.concat(response.data);
            } while (response.data.length === 100);

            let additions = 0;
            let deletions = 0;
            let filesChanged = files.length;
            let filesAdded = 0;
            let filesDeleted = 0;
            let filesModified = 0;
            let filesRenamed = 0;

            files.forEach(file => {
              additions += file.additions || 0;
              deletions += file.deletions || 0;

              if (file.status === 'added') filesAdded++;
              else if (file.status === 'removed') filesDeleted++;
              else if (file.status === 'modified') filesModified++;
              else if (file.status === 'renamed') filesRenamed++;
            });

            // Get all commits in the PR with pagination
            let commits = [];
            page = 1;
            
            do {
              response = await github.rest.pulls.listCommits({
                owner: context.repo.owner,
                repo: context.repo.repo,
                pull_number: pr.number,
                per_page: 100,
                page: page++
              });
              commits = commits.concat(response.data);
            } while (response.data.length === 100);

            const commitCount = commits.length;

            // Format numbers with thousand separators
            const formatNumber = num => num.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ',');

            // Calculate PR size (matching size/* labels)
            const prSize = additions + deletions;
            let sizeEmoji, sizeLabel;
            if (prSize < 10) {
              sizeEmoji = 'üü¢';
              sizeLabel = 'XS';
            } else if (prSize < 100) {
              sizeEmoji = 'üü¢';
              sizeLabel = 'S';
            } else if (prSize < 500) {
              sizeEmoji = 'üü°';
              sizeLabel = 'M';
            } else if (prSize < 1000) {
              sizeEmoji = 'üü†';
              sizeLabel = 'L';
            } else {
              sizeEmoji = 'üî¥';
              sizeLabel = 'XL';
            }

            // Check if comment already exists
            const comments = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: pr.number
            });

            const botComment = comments.data.find(comment =>
              comment.user.type === 'Bot' &&
              comment.body.includes('üìä Pull Request Statistics')
            );

            const commentBody = [
              '## üìä Pull Request Statistics',
              '',
              '### üìà Changes Overview',
              '',
              '| Metric | Value |',
              '|--------|-------|',
              `| üü¢ **Lines Added** | \`+${formatNumber(additions)}\` |` ,
              `| üî¥ **Lines Deleted** | \`-${formatNumber(deletions)}\` |` ,
              `| üìä **Net Change** | \`${additions - deletions > 0 ? '+' : ''}${formatNumber(additions - deletions)}\` |` ,
              `| üìÅ **Files Changed** | \`${formatNumber(filesChanged)}\` |` ,
              `| ‚ú® **Files Added** | \`${formatNumber(filesAdded)}\` |` ,
              `| ‚úèÔ∏è **Files Modified** | \`${formatNumber(filesModified)}\` |` ,
              `| üîÑ **Files Renamed** | \`${formatNumber(filesRenamed)}\` |` ,
              `| üóëÔ∏è **Files Deleted** | \`${formatNumber(filesDeleted)}\` |` ,
              `| üìù **Commits** | \`${formatNumber(commitCount)}\` |` ,
              '',
              '### üì¶ PR Size',
              '',
              `${sizeEmoji} **${sizeLabel}** ‚Äî \`${formatNumber(prSize)}\` total changes` ,
              '',
              '---',
              '',
              '<sub>üí° *This comment updates automatically on each push*</sub>'
            ].join('\n');

            if (botComment) {
              // Update existing comment
              await github.rest.issues.updateComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: botComment.id,
                body: commentBody
              });
            } else {
              // Create new comment
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: pr.number,
                body: commentBody
              });
            }